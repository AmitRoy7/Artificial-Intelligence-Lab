\documentclass[11pt , conference]{IEEEtran}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage[justification=centering]{caption}
\usepackage{amsmath}
\usepackage{float}
\usepackage[table]{xcolor}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{cite}
\usepackage{subcaption}
\captionsetup{font=small}
\graphicspath{}
\DeclareGraphicsExtensions{.jpg,.png}
\usepackage{fancyhdr,lipsum}
\usepackage{kantlipsum}
\newcommand\tab[1][0.5cm]{\hspace*{#1}}
\usepackage{hyperref}
\usepackage{textcomp}
\pagestyle{plain}
\setcounter{page}{1}


\begin{document}

	
	\title{\LARGE Constraint Satisfaction Problem(CSP) \\Comparative Performance Analysis of Arc-Consistency Algorithms\\AC-1, AC-2, AC-3, AC4}
	\author
	{	Amit Roy, Roll: JH-40
		\\Department of Computer Science and Engineering,\\University of Dhaka,\\Email: \href{mailto:aroy7298@gmail.com}{aroy7298@gmail.com}
	}
	\maketitle
	\fontsize{12pt}{12pt}\selectfont\noindent
	
		\section{Implementation Details:}
	In this assignment, our goal was to implement the arc consistency algorithms \textbf{(AC-1, AC-2, AC-3, AC-4)} to reduce the domain of the variables of \textbf{Constraint Satisfaction Problem(CSP)} by applying constraint propagation.\\
	According to the previously submitted concise problem definition we will have a set of \textbf{variables(eg. 50,100,150,200)} which will have a domain of random size in the range \textbf{1\texttildelow50} where the values of the domain will contain integers from the range \textbf{1\texttildelow1000}. The variables of the CSP are treated as the nodes of a graph.\\The graph is generated by a \textbf{random matrix} using \textbf{numpy}, a python library. The random adjacency matrix should be a \textbf{symmetric matrix} (i.e. if there is an edge between \textbf{u $\rightarrow$ v} there should be an edge between \textbf{v $\rightarrow$ u} ) without any self loop because all the constraints are binary constraints so we don't need edge between a node and itself. Since there is a \textbf{constraint} for every edge between  any two nodes in the graph so for \textbf{n} nodes I have generated a \textbf{n * n} adjacency matrix where the each entry of the matrix could be an integer between 0 to 11 where 0 denotes no edge and other nonzero entries denote the constraint between two adjacent nodes. I used the following constrains in my implementation:\\\\\textbf{Constraints:}
	\begin{equation}
	y \leq x
	\end{equation}
	\begin{equation}
	y \geq x
	\end{equation}
	\begin{equation}
	y=x
	\end{equation}
	\begin{equation}
	y \neq x
	\end{equation}
	\begin{equation}
	y\%x=0 \mbox{, y divides x}
	\end{equation}
	\begin{equation}
	gcd(x,y)=1 \mbox{ i.e. x and y are co-prime}
	\end{equation}
	\begin{equation}
	y=mx + c \mbox{, m and c are constants (m=2 and c = 1)}
	\end{equation}
	\begin{equation}
	y=ax^2 + bx + c \mbox{,a,b and c are constant (a=1,b=1,c=1)}
	\end{equation}
	
		For the constraints \textbf{1,2,5,7,8} we need to map them to different value for different pair of variables because they don't follow the commutative rule that is if \textbf{u$\leq$v} then \textbf{v$\geq$u}
	
	\section{Comparative Performance Analysis}	To compare the performance of the arc consistency algorithms we used two performance metrics of the graph. 
	\begin{enumerate}
\item [(a)] \textit{Running Time (msec) vs Number of nodes}
\item [(b)] \textit{Running Time (msec) vs Percentage of edges}
	\end{enumerate}
	\subsection{Running Time (msec) vs Number of nodes}
	I have used the Alan Mackworth's \textbf{Consistency in Network Relations}\cite{DUMMY:1} as a source of the \textbf{AC1}, \textbf{AC2}, \textbf{AC3} algorithms and \cite{DUMMY:2} for implementing \textbf{AC4}. 
	While comparing the algorithms we have noticed that \ref{figure 1} \ref{figure 2} \ref{figure 3} \textbf{AC3} performs better than \textbf{AC1}. These two algorithms are almost same except the fact that \textbf{AC1} checks consistency of all the arcs even if only one edge is revised. But \textbf{AC3} checks the consistency only the adjacent edges of the first node of the revised edge.So, it's a reason behind \textbf{AC3} performing better another reason is when the domain of any node is empty \textbf{AC3} terminates.\textbf{AC2} also performs better than \textbf{AC1} but it's performance is almost same \textbf{AC3} in most of the cases. While \textbf{AC3} almost always better than \textbf{AC4}\cite{DUMMY:3}
	
	\subsection{Running Time (msec) vs Percentage of edges}
	As I have increased the percentage of edges in the graph keeping the number of nodes fixed(eg. 100,200). I got the same result as the previous one. The running time of \textbf{AC3} and \textbf{AC1} is quite better than the \textbf{AC2} and \textbf{AC4}. For \textbf{AC1} and \textbf{AC3} we have noticed that their performance are almost similar for small percentage of edges but when edge percentages then \textbf{AC3} performs slightly better than \textbf{AC1}. But \textbf{AC2} and \textbf{AC4} are not so good even for small edge percentages.
	\newpage
	\begin{figure}[h]
		\centering
		\includegraphics[width=8cm]{running_time_node_100.png}
		\captionsetup{singlelinecheck = false, format= hang,  font=footnotesize, labelsep=space}
		\caption{Running time vs number of nodes (1\texttildelow100)}
		\label{figure 1}
	\end{figure}
	\begin{figure}[h]
		\centering
		\includegraphics[width=8cm]{running_time_node_200.png}
		\captionsetup{singlelinecheck = false, format= hang,  font=footnotesize, labelsep=space}
		\caption{Running time vs number of nodes (1\texttildelow200)}
		\label{figure 2}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=8cm]{running_time_edge_100.png}
		\captionsetup{singlelinecheck = false, format= hang,  font=footnotesize, labelsep=space}
		\caption{Edge Percentage vs number of nodes (Nodes: 100)}
		\label{figure 3}
	\end{figure}
	
	\begin{figure}[h]
		\centering
		\includegraphics[width=8cm]{running_time_edge_200.png}
		\captionsetup{singlelinecheck = false, format= hang,  font=footnotesize, labelsep=space}
		\caption{Edge Percentage vs number of nodes (Nodes: 200)}
		\label{figure 4}
	\end{figure}

	\section{Conclusion}	
	\noindent
	Since all the algorithms reduce the domain of the variables by eliminating inconsistent values from the domain, all algorithms will return the \textbf{same domain} if the input graph has a consistent solution. But when the input graph is not consistent then, different algorithms may return different domain due to the termination when some of the variable's domain is empty.\\\\To verify the correctness of the implementation, I have run all 4 algorithms for small input until finding a consistent graph. What we have noticed is all 4 algorithms provide same domain for each variable/node. which proves the correctness of the implementation. I have run all the algorithms in the platform \textbf{``google colab"}. You can find and test the implementation \href{https://tinyurl.com/solutionAC-040}{here}
	
	
	
	\newpage
	\bibliography{bibTex} 
	\bibliographystyle{ieeetr}
	
\end{document}
